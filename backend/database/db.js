const sqlite3 = require("sqlite3").verbose(); const path = require("path"); const dbPath = path.join(__dirname, "email_sender.db"); const db = new sqlite3.Database(dbPath, (err) => { if (err) { console.error("Error opening database:", err.message); } else { console.log("Connected to SQLite database"); initializeTables(); } }); function initializeTables() { db.run(`CREATE TABLE IF NOT EXISTS emails ( id INTEGER PRIMARY KEY AUTOINCREMENT, email TEXT NOT NULL UNIQUE, status TEXT DEFAULT "pending", created_at DATETIME DEFAULT CURRENT_TIMESTAMP, sent_at DATETIME NULL, error_message TEXT NULL )`); db.run(`CREATE TABLE IF NOT EXISTS smtp_config ( id INTEGER PRIMARY KEY AUTOINCREMENT, host TEXT NOT NULL, port INTEGER NOT NULL, user TEXT NOT NULL, pass TEXT NOT NULL, secure BOOLEAN DEFAULT 0, created_at DATETIME DEFAULT CURRENT_TIMESTAMP )`); db.run(`CREATE TABLE IF NOT EXISTS settings ( id INTEGER PRIMARY KEY AUTOINCREMENT, delay_ms INTEGER DEFAULT 1000, max_emails_per_day INTEGER DEFAULT 100, created_at DATETIME DEFAULT CURRENT_TIMESTAMP )`); } const dbHelpers = { getAllEmails: () => new Promise((resolve, reject) => { db.all("SELECT * FROM emails ORDER BY created_at DESC", (err, rows) => { if (err) reject(err); else resolve(rows); }); }), addEmail: (email) => new Promise((resolve, reject) => { db.run("INSERT INTO emails (email) VALUES (?)", [email], function(err) { if (err) reject(err); else resolve({ id: this.lastID, email, status: "pending" }); }); }), updateEmailStatus: (id, status, errorMessage = null) => new Promise((resolve, reject) => { const sentAt = status === "sent" ? new Date().toISOString() : null; db.run("UPDATE emails SET status = ?, sent_at = ?, error_message = ? WHERE id = ?", [status, sentAt, errorMessage, id], function(err) { if (err) reject(err); else resolve({ changes: this.changes }); }); }), getSmtpConfig: () => new Promise((resolve, reject) => { db.get("SELECT * FROM smtp_config ORDER BY created_at DESC LIMIT 1", (err, row) => { if (err) reject(err); else resolve(row); }); }), saveSmtpConfig: (config) => new Promise((resolve, reject) => { const { host, port, user, pass, secure } = config; db.run("INSERT INTO smtp_config (host, port, user, pass, secure) VALUES (?, ?, ?, ?, ?)", [host, port, user, pass, secure ? 1 : 0], function(err) { if (err) reject(err); else resolve({ id: this.lastID, ...config }); }); }), getSettings: () => new Promise((resolve, reject) => { db.get("SELECT * FROM settings ORDER BY created_at DESC LIMIT 1", (err, row) => { if (err) reject(err); else resolve(row || { delay_ms: 1000, max_emails_per_day: 100 }); }); }), saveSettings: (settings) => new Promise((resolve, reject) => { const { delay_ms, max_emails_per_day } = settings; db.run("INSERT INTO settings (delay_ms, max_emails_per_day) VALUES (?, ?)", [delay_ms, max_emails_per_day], function(err) { if (err) reject(err); else resolve({ id: this.lastID, ...settings }); }); }), getTodayEmailCount: () => new Promise((resolve, reject) => { const today = new Date().toISOString().split("T")[0]; db.get("SELECT COUNT(*) as count FROM emails WHERE DATE(sent_at) = ? AND status = \"sent\"", [today], (err, row) => { if (err) reject(err); else resolve(row.count || 0); }); }) };

function updateEmail(id, email) { return new Promise((resolve, reject) => { db.run("UPDATE emails SET email = ? WHERE id = ?", [email, id], function(err) { if (err) reject(err); else resolve({ changes: this.changes }); }); }); }
function deleteEmail(id) { return new Promise((resolve, reject) => { db.run("DELETE FROM emails WHERE id = ?", [id], function(err) { if (err) reject(err); else resolve({ changes: this.changes }); }); }); }
function clearEmails() { return new Promise((resolve, reject) => { db.run("DELETE FROM emails", [], function(err) { if (err) reject(err); else resolve({ changes: this.changes }); }); }); }

module.exports = { db, ...dbHelpers, updateEmail, deleteEmail, clearEmails };
